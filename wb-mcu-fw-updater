#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import logging
import atexit
from subprocess import CalledProcessError
from wb_mcu_fw_updater import fw_downloader, update_monitor, user_log, die, CONFIG
from wb_modbus.bindings import WBModbusDeviceBase, close_all_modbus_ports
from wb_modbus.minimalmodbus import ModbusException


def get_correct_modbus_connection(args):
    """
    Updating device, working in normal mode. Port name is compulsory.
    """
    modbus_connection = WBModbusDeviceBase(args.slaveid, args.port, debug=True)
    modbus_connection.set_port_settings(*update_monitor._parse_uart_params_str(args.uart_settings))
    if args.unknown_uart_settings:
        """
        Applying found uart settings to modbus_connection instance.
        """
        try:
            uart_settings = modbus_connection.find_uart_settings(modbus_connection.get_slave_addr)
        except RuntimeError as e:
            logging.error('Device is disconnected or slaveid is wrong')
            die(e)
        logging.info('Has found UART settings: %s' % str(uart_settings))
        modbus_connection.set_port_settings_raw(uart_settings)
    return modbus_connection


def update_fw(args):
    """
    Updating device's firmware.
    Could install specified fw_version from specified branch.
    """
    modbus_connection = get_correct_modbus_connection(args)
    try:
        update_monitor.flash_alive_device(modbus_connection, 'fw', args.branch_name, args.specified_version, args.force, args.erase_settings)
    except ModbusException as e:
        logging.error("Check device's connection, slaveid and UART settings!")
        die(e)
    except CalledProcessError as e:
        logging.error("Flashing has failed!")
        die(e)


def update_bootloader(args):
    """
    Updating device's bootloader.
    Only latest version from stable branch is available.
    """
    modbus_connection = get_correct_modbus_connection(args)
    try:
        update_monitor.flash_alive_device(modbus_connection, 'bootloader', '', 'latest', args.force, erase_settings=False)
    except ModbusException as e:
        logging.error("Check device's connection, slaveid and UART settings!")
        die(e)
    except CalledProcessError as e:
        logging.error("Flashing has failed!")
        die(e)


def recover_fw(args):
    """
    Recovering the device, stuck in the bootloader by already known fw_signature.
    """
    fw_signatures_list = fw_downloader.get_fw_signatures_list()
    if args.known_signature is None:
        logging.warning("Restoring device's fw_signature from db by slaveid: %d and port %s" % (args.slaveid, args.port))
        fw_signature = update_monitor.db.get_fw_signature(args.slaveid, args.port)
        if fw_signature:
            update_monitor.recover_device_iteration(fw_signature, args.slaveid, args.port)
        else:
            die('No data has found. Specify fw_signature manually via --fw-sig key')
    elif args.known_signature in fw_signatures_list:
        update_monitor.recover_device_iteration(args.known_signature, args.slaveid, args.port)
    else:
        die('Choose a fw_signature from : %s' % (', '.join(fw_signatures_list))) #DO NOT use argparse's choices! (logging could be incorrect)


def update_all(args):
    """
    Updating firmwares for all devices, specified in wb-mqtt-serial's config.
    """
    update_monitor._update_all(force=args.force)


def recover_all(args):
    """
    Trying to recover all devices, specified in wb-mqtt-serial's config.
    """
    update_monitor._recover_all()


def parse_args():
    main_parser = argparse.ArgumentParser(prog='wb-mcu-fw-updater', formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                          description='Wiren Board modbus devices firmware/bootloader update tool.', add_help=True)
    main_parser.add_argument('--debug', dest='user_loglevel', default=None, action='store_const',
                             const=10, help='Setting the least loglevel. (Default: %(default)s)')
    subparsers = main_parser.add_subparsers(
        title='Actions', help='Choose functionality mode')

    """
    Updating firmware on single working device.
    """
    update_fw_parser = subparsers.add_parser(
        'update-fw', help='Update firmware on single working device.')
    update_fw_parser.add_argument('--branch', type=str, dest='branch_name', metavar='<branch_name>', default='',
                                  help='Install firmware from specified branch. (Default: %(default)s)')
    update_fw_parser.add_argument('--version', type=str, dest='specified_version', metavar='<fw_version>',
                                  default='latest', help='Download a specified firmware version. (Default: %(default)s)')
    update_fw_parser.add_argument('--restore-defaults', action='store_true', dest='erase_settings',
                                  default=False, help="Erase all device's settings during update. (Default: %(default)s)")
    update_fw_parser.add_argument('--uart', metavar='<uart_settings_str>', type=str, dest='uart_settings',
                                  default='9600-N-2', help='UART settings string. (Default: %(default)s)')
    update_fw_parser.add_argument('--find-uart', action='store_true', dest='unknown_uart_settings',
                                  default=False, help='Automatically find UART settings of device. (Default: %(default)s)')
    update_fw_parser.add_argument('--force', action='store_true', dest='force', default=False,
                                  help='Perform force device reflash, even if firmware is latest. (Default: %(default)s)')
    update_fw_parser.add_argument(
        '-a', '--slaveid', type=int, dest='slaveid', metavar='<slaveid>', required=True, help='Slave address of the device.')
    update_fw_parser.add_argument(
        "port", type=str, metavar='<port>', help='Serial port, device connected to.')
    update_fw_parser.set_defaults(func=update_fw)

    """
    Updating bootloader on single working device.
    """
    update_bootloader_parser = subparsers.add_parser(
        'update-bl', help='Update bootloader on single working device.')
    update_bootloader_parser.add_argument('--uart', type=str, metavar='<uart_settings_str>', dest='uart_settings',
                                          default='9600-N-2', help='UART settings string. (Default: %(default)s)')
    update_bootloader_parser.add_argument('--find-uart', action='store_true', dest='unknown_uart_settings',
                                          default=False, help='Automatically find UART settings of device. (Default: %(default)s)')
    update_bootloader_parser.add_argument('-f', '--force', action='store_true', dest='force', default=False,
                                          help='Perform force device reflash, even if firmware is latest. (Default: %(default)s)')
    update_bootloader_parser.add_argument(
        '-a', '--slaveid', type=int, metavar='<slaveid>', dest='slaveid', required=True, help='Slave address of the device.')
    update_bootloader_parser.add_argument(
        "port", type=str, metavar='<port>', help='Serial port, device connected to.')
    update_bootloader_parser.set_defaults(func=update_bootloader)

    """
    Flash single device, stuck in the bootloader.
    """
    recover_fw_parser = subparsers.add_parser(
        'recover', help="Flash single device, stuck in bootloader to it's latest firmware. Device model name (or known firmware signature) is required!")
    recover_fw_parser.add_argument('--fw-sig', dest='known_signature', type=str, metavar='<fw_signature>', default=None,
                                   help="Force specify device's firmware signature. (Default: %(default)s)")
    recover_fw_parser.add_argument('--restore-defaults', action='store_true', dest='erase_settings',
                                   default=False, help="Erase all device's settings during flashing. (Default: %(default)s)")
    recover_fw_parser.add_argument(
        '-a', '--slaveid', type=int, dest='slaveid', metavar='<slaveid>', required=True, help='Slave address of the device.')
    recover_fw_parser.add_argument(
        "port", type=str, metavar='<port>', help='Serial port, device connected to.')
    recover_fw_parser.set_defaults(func=recover_fw)

    """
    Update firmware on all devices, found in wb-mqtt-serial config.
    """
    update_all_fw_parser = subparsers.add_parser(
        'update-all', help="Trying to update all devices, added to wb-mqtt-serial's config.")
    update_all_fw_parser.add_argument('--force', action='store_true', dest='force', default=False,
                                      help='Perform force updates of all devices, even if firmwares are latest. (Default: %(default)s)')
    update_all_fw_parser.set_defaults(func=update_all)

    recover_all_parser = subparsers.add_parser(
        'recover-all', help="Trying to recover all devices, added to wb-mqtt-serial's config.")
    recover_all_parser.set_defaults(func=recover_all)

    args = main_parser.parse_args()
    if 'func' in vars(args):
        return args
    else:
        main_parser.print_usage()
        die('No action has chosen!')


if __name__ == "__main__":
    try:
        args = parse_args()

        user_log.setup_syslog_logger()
        user_log.setup_user_logger((args.user_loglevel or CONFIG['USER_LOGLEVEL']))

        update_monitor.pause_driver()
        atexit.register(update_monitor.resume_driver)
        atexit.register(close_all_modbus_ports)

        args.func(args)

    except KeyboardInterrupt as e:
        die(e)
