#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import logging
import atexit
from subprocess import CalledProcessError
from wb_mcu_fw_updater import fw_downloader, update_monitor, user_log, die, CONFIG
from wb_modbus.bindings import WBModbusDeviceBase, close_all_modbus_ports
from wb_modbus.minimalmodbus import ModbusException


def update_alive_device(args):
    """
    Updating device, working in normal mode. Port name is compulsory.
    """
    modbus_connection = WBModbusDeviceBase(args.slaveid, args.port, debug=True)
    modbus_connection.set_port_settings(*update_monitor._parse_uart_params_str(args.uart_settings))
    if args.unknown_uart_settings:
        """
        Applying found uart settings to modbus_connection instance.
        """
        try:
            uart_settings = modbus_connection.find_uart_settings(modbus_connection.get_slave_addr)
        except RuntimeError as e:
            logging.error('Device is disconnected or slaveid is wrong')
            die(e)
        logging.info('Has found UART settings: %s' % str(uart_settings))
        modbus_connection.set_port_settings_raw(uart_settings)
    try:
        update_monitor.flash_alive_device(modbus_connection, args.mode, args.branch_name, args.specified_version, args.force, args.erase_settings)
    except ModbusException as e:
        logging.error("Check device's connection, slaveid and UART settings!")
        die(e)
    except CalledProcessError as e:
        logging.error("Flashing has failed!")
        die(e)


def recover(args):
    """
    Flashing device, stuck in the bootloader. Unstable FW branches are not allowed.
    """
    fw_signatures_list = fw_downloader.get_fw_signatures_list()
    if args.known_signature is None:
        logging.warning("Restoring device's fw_signature from db by slaveid: %d and port %s" % (args.slaveid, args.port))
        fw_signature = update_monitor.db.get_fw_signature(args.slaveid, args.port)
        if fw_signature:
            update_monitor.recover_device_iteration(fw_signature, args.slaveid, args.port)
        else:
            die('No data has found. Specify fw_signature manually via --signature key')
    elif args.known_signature in fw_signatures_list:
        update_monitor.recover_device_iteration(args.known_signature, args.slaveid, args.port)
    else:
        die('Choose a fw_signature from : %s' % (', '.join(fw_signatures_list))) #DO NOT use argparse's choices! (logging could be incorrect)


def update_all(args):
    update_monitor._update_all(force=args.force)


def recover_all(args):
    update_monitor._recover_all()


def show_typical_usage(progname):
    update_alive_device_example = '%s update <port> -a <slaveid>' % progname
    update_alive_device_custom_uart_example = '%s update <port> -a <slaveid> --uart-params 115200-N-2' % progname
    update_alive_device_unknown_example = '%s update <port> --find-uart' % progname
    recover_auto_example = '%s recover <port>' % progname
    recover_with_known_fw_signature_example = '%s recover <port> <firmware_signature>' % progname
    update_all_example = '%s update-all' % progname
    typical_usage_str = """\
    Some typical usage cases

    Updating a device with known slaveid and default UART params (9600-N-2):
    \t%s
    Updating a device with known slaveid and custom UART params (115200-N-2, for example):
    \t%s
    Updating a device with unknown slaveid and unknown UART settings:
    \t%s
    Recovering a device, stuck in the bootloader with known fw_signature:
    \t%s
    Recovering a device, stuck in the bootloader (auto mode):
    \t%s
    Updating all devices, found in wb-mqtt-serial config:
    \t%s
    """ % (update_alive_device_example, update_alive_device_custom_uart_example, update_alive_device_unknown_example, recover_with_known_fw_signature_example, recover_auto_example, update_all_example)
    print(typical_usage_str)


def parse_args():
    main_parser = argparse.ArgumentParser(prog='wb-mcu-fw-updater', formatter_class=argparse.ArgumentDefaultsHelpFormatter, description='WirenBoard modbus devices firmware update tool', add_help=True)
    main_parser.add_argument('--debug', dest='user_loglevel', default=None, action='store_const', const=10, help='Displaying all log records.')
    subparsers = main_parser.add_subparsers()

    update_parser = subparsers.add_parser('update', help='Update firmware on single working device.')
    update_parser.add_argument("port", type=str, help='Serial port, device connected to.')
    update_parser.add_argument('-a', '--slaveid', type=int, dest='slaveid', required=True, help='Slave address of the device.')
    update_parser.add_argument('--branch', type=str, dest='branch_name', default='', help='Install firmware from specified branch.')
    update_parser.add_argument('--mode', type=str, dest='mode', default='fw', choices=('fw', 'bootloader'), help='Update firmware or bootloader.')
    update_parser.add_argument('--uart-params', type=str, dest='uart_settings', default='9600-N-2', help='UART settings string (ex: 9600-N-2).')
    update_parser.add_argument('--find-uart', action='store_true', dest='unknown_uart_settings', default=False, help='UART settings of device will be found via iterating over all allowed.')
    update_parser.add_argument('--restore-defaults', action='store_true', dest='erase_settings', default=False, help="Erase all device's settings during update.")
    update_parser.add_argument('--force', action='store_true', dest='force', default=False, help='Perform force device reflash, even if firmware is latest.')
    update_parser.add_argument('--version', type=str, dest='specified_version', default='latest', help='Download a specified firmware version.')
    update_parser.set_defaults(func=update_alive_device)

    recover_parser = subparsers.add_parser('recover', help="Flash single device, stuck in bootloader to it's latest firmware. Device model name (or known firmware signature) is required!")
    recover_parser.add_argument("port", type=str, help='Serial port, device connected to.')
    recover_parser.add_argument('--signature', dest='known_signature', type=str, default=None, help="Force specify device's firmware signature.")
    recover_parser.add_argument('-a', '--slaveid', type=int, dest='slaveid', required=True, help='Slave address of the device.')
    recover_parser.add_argument('--restore-defaults', action='store_true', dest='erase_settings', default=False, help="Erase all device's settings during update.")
    recover_parser.set_defaults(func=recover)

    update_all_parser = subparsers.add_parser('update-all', help="Trying to update all devices, added to wb-mqtt-serial's config.")
    update_all_parser.add_argument('--force', action='store_true', dest='force', default=False, help='Perform force device update, even if firmware is latest.')
    update_all_parser.set_defaults(func=update_all)

    recover_all_parser = subparsers.add_parser('recover-all', help="Trying to recover all devices, added to wb-mqtt-serial's config.")
    recover_all_parser.set_defaults(func=recover_all)

    args = main_parser.parse_args()
    if 'func' in vars(args):
        return args
    else:
        print(main_parser.format_usage())
        show_typical_usage(main_parser.prog)
        die('No action has chosen!')


if __name__ == "__main__":
    try:
        args = parse_args()

        user_log.setup_syslog_logger()
        user_log.setup_user_logger((args.user_loglevel or CONFIG['USER_LOGLEVEL']))

        update_monitor.pause_driver()
        atexit.register(update_monitor.resume_driver)
        atexit.register(close_all_modbus_ports)

        args.func(args)

    except KeyboardInterrupt as e:
        die(e)
