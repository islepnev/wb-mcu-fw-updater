#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import logging
import atexit
from subprocess import CalledProcessError
from wb_mcu_fw_updater import fw_downloader, update_monitor, user_log, die, CONFIG
from wb_modbus.bindings import WBModbusDeviceBase, close_all_modbus_ports
from wb_modbus.minimalmodbus import ModbusException


def update_alive_device(args):
    """
    Updating device, working in normal mode. Port name is compulsory.
    """
    modbus_connection = WBModbusDeviceBase(args.slaveid, args.port, debug=True)
    modbus_connection.set_port_settings(*update_monitor._parse_uart_params_str(args.uart_settings))
    if args.unknown_uart_settings:
        """
        Applying found uart settings to modbus_connection instance.
        """
        try:
            uart_settings = modbus_connection.find_uart_settings(modbus_connection.get_slave_addr)
        except RuntimeError as e:
            logging.error('Device is disconnected or slaveid is wrong')
            die(e)
        logging.info('Has found UART settings: %s' % str(uart_settings))
        modbus_connection.set_port_settings_raw(uart_settings)
    try:
        update_monitor.flash_alive_device(modbus_connection, args.mode, args.branch_name, args.specified_version, args.force, args.erase_settings)
    except ModbusException as e:
        logging.error("Check device's connection, slaveid and UART settings!")
        die(e)


def recover(args):
    """
    Flashing device, stuck in the bootloader. Unstable FW branches are not allowed.
    """
    downloader = fw_downloader.RemoteFileWatcher(mode='fw', branch_name='')
    fw_version = 'latest'
    fw_signatures_list = fw_downloader.get_fw_signatures_list()
    modbus_connection = WBModbusDeviceBase(args.slaveid, args.port, debug=True)
    if args.known_signature is None:
        fpath = CONFIG['LAST_FW_SIGNATURE_FNAME']
        logging.warn('Will try to recover fw signature from: %s' % fpath)
        try:
            fw_signature = open(fpath).read().strip()
            downloaded_fw = downloader.download(fw_signature, fw_version)
            update_monitor.flash_in_bootloader(downloaded_fw, modbus_connection, args.erase_settings)
        except (CalledProcessError, IOError) as e: # If file not found or fw_signature was wrong
            logging.warn('Failed. Will try all possigle fw signatures:')
            for fw_signature in fw_signatures_list:
                logging.debug('Trying %s:' % fw_signature)
                downloaded_fw = downloader.download(fw_signature, fw_version)
                try:
                    update_monitor.flash_in_bootloader(downloaded_fw, modbus_connection, args.erase_settings, response_timeout=0.5)
                    logging.info('Successfully recovered device with fw_signature: %s' % fw_signature)
                    return
                except CalledProcessError:
                    logging.error('Failed')
            else:
                die('Valid fw_signature was not found!')
    elif args.known_signature in fw_signatures_list:
        downloaded_fw = downloader.download(args.known_signature, fw_version)
        update_monitor.flash_in_bootloader(downloaded_fw, modbus_connection, args.erase_settings)
    else:
        die('Choose a fw_signature from : %s' % (', '.join(fw_signatures_list))) #DO NOT use argparse's choices! (logging could be incorrect)


def update_all(args):
    """
    Parsing driver_config for a list of devices on all ports. Trying to update each device.
    """
    downloader = fw_downloader.RemoteFileWatcher(mode='fw', branch_name='')
    fw_version = 'latest'
    overall_fails = {}
    for port, port_params in update_monitor.get_devices_on_driver(CONFIG['SERIAL_DRIVER_CONFIG_FNAME']).items():
        uart_params = port_params['uart_params']
        devices_on_port = port_params['devices']
        failed_devices = []
        for device_name, device_slaveid in devices_on_port:
            logging.debug('Trying to update %s with slaveid %d:' % (device_name, device_slaveid))
            modbus_connection = WBModbusDeviceBase(device_slaveid, port, *uart_params, debug=True)
            try:
                update_monitor.flash_alive_device(modbus_connection, 'fw', '', fw_version, args.force, False)
            except Exception as e:
                logging.warn('Update for %s : %d failed!' % (device_name, device_slaveid), exc_info=True)
                failed_devices.append([device_name, device_slaveid])
        if failed_devices:
            overall_fails.update({port : failed_devices})
    if overall_fails:
        die('Update has failed for:\n%s\nCheck syslog for more info' % (str(overall_fails)))


def show_typical_usage(progname):
    update_alive_device_example = '%s update <port> -a <slaveid>' % progname
    update_alive_device_custom_uart_example = '%s update <port> -a <slaveid> --uart-params 115200-N-2' % progname
    update_alive_device_unknown_example = '%s update <port> --find-uart' % progname
    recover_auto_example = '%s recover <port>' % progname
    recover_with_known_fw_signature_example = '%s recover <port> <firmware_signature>' % progname
    update_all_example = '%s update-all' % progname
    typical_usage_str = """\
    Some typical usage cases

    Updating a device with known slaveid and default UART params (9600-N-2):
    \t%s
    Updating a device with known slaveid and custom UART params (115200-N-2, for example):
    \t%s
    Updating a device with unknown slaveid and unknown UART settings:
    \t%s
    Recovering a device, stuck in the bootloader with known fw_signature:
    \t%s
    Recovering a device, stuck in the bootloader (auto mode):
    \t%s
    Updating all devices, found in wb-mqtt-serial config:
    \t%s
    """ % (update_alive_device_example, update_alive_device_custom_uart_example, update_alive_device_unknown_example, recover_with_known_fw_signature_example, recover_auto_example, update_all_example)
    print(typical_usage_str)


def parse_args():
    main_parser = argparse.ArgumentParser(prog='wb-mcu-fw-updater', formatter_class=argparse.ArgumentDefaultsHelpFormatter, description='WirenBoard modbus devices firmware update tool')
    main_parser.add_argument('--debug', dest='user_loglevel', default=None, action='store_const', const=10, help='Displaying all log records.')
    subparsers = main_parser.add_subparsers()

    update_parser = subparsers.add_parser('update', help='Update firmware on single working device.')
    update_parser.add_argument("port", type=str, help='Serial port, device connected to.')
    update_parser.add_argument('-a', '--slaveid', type=int, dest='slaveid', required=True, help='Slave address of the device.')
    update_parser.add_argument('--branch', type=str, dest='branch_name', default='', help='Install firmware from specified branch.')
    update_parser.add_argument('--mode', type=str, dest='mode', default='fw', choices=('fw', 'bootloader'), help='Update firmware or bootloader.')
    update_parser.add_argument('--uart-params', type=str, dest='uart_settings', default='9600-N-2', help='UART settings string (ex: 9600-N-2).')
    update_parser.add_argument('--find-uart', action='store_true', dest='unknown_uart_settings', default=False, help='UART settings of device will be found via iterating over all allowed.')
    update_parser.add_argument('--restore-defaults', action='store_true', dest='erase_settings', default=False, help="Erase all device's settings during update.")
    update_parser.add_argument('--force', action='store_true', dest='force', default=False, help='Perform force device reflash, even if firmware is latest.')
    update_parser.add_argument('--version', type=str, dest='specified_version', default='latest', help='Download a specified firmware version.')
    update_parser.set_defaults(func=update_alive_device)

    recover_parser = subparsers.add_parser('recover', help="Flash single device, stuck in bootloader to it's latest firmware. Device model name (or known firmware signature) is required!")
    recover_parser.add_argument("port", type=str, help='Serial port, device connected to.')
    recover_parser.add_argument('--signature', dest='known_signature', type=str, default=None, help="Force specify device's firmware signature.")
    recover_parser.add_argument('-a', '--slaveid', type=int, dest='slaveid', required=True, help='Slave address of the device.')
    recover_parser.add_argument('--restore-defaults', action='store_true', dest='erase_settings', default=False, help="Erase all device's settings during update.")
    recover_parser.set_defaults(func=recover)

    update_all_parser = subparsers.add_parser('update-all', help="Trying to update all devices, added to wb-mqtt-serial's config.")
    update_all_parser.add_argument('--force', action='store_true', dest='force', default=False, help='Perform force device update, even if firmware is latest.')
    update_all_parser.set_defaults(func=update_all)

    args = main_parser.parse_args()
    if 'func' in vars(args):
        return args
    else:
        print(main_parser.format_usage())
        show_typical_usage(main_parser.prog)
        die('No action has chosen!')


if __name__ == "__main__":
    try:
        args = parse_args()

        user_log.setup_syslog_logger()
        user_log.setup_user_logger((args.user_loglevel or CONFIG['USER_LOGLEVEL']))

        update_monitor.pause_driver()
        atexit.register(update_monitor.resume_driver)
        atexit.register(close_all_modbus_ports)

        args.func(args)

    except KeyboardInterrupt as e:
        die(e)
